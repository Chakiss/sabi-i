// üîê Enhanced Authentication Context with Role-Based Access Control
'use client';

import { createContext, useContext, useEffect, useState, useCallback } from 'react';
import { 
  signInWithEmailAndPassword, 
  createUserWithEmailAndPassword,
  signInWithPopup,
  GoogleAuthProvider,
  RecaptchaVerifier,
  signInWithPhoneNumber,
  signOut,
  onAuthStateChanged
} from 'firebase/auth';
import { doc, getDoc, setDoc, updateDoc, deleteDoc, collection, getDocs, query, orderBy } from 'firebase/firestore';
import { auth, db } from '../lib/firebase';
import toast from 'react-hot-toast';

const AuthContext = createContext({});

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [userRole, setUserRole] = useState('viewer'); // Default role: viewer
  const [loading, setLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false);

  // Load cached role from localStorage
  const getCachedRole = (uid) => {
    try {
      const cached = localStorage.getItem(`userRole_${uid}`);
      return cached || 'viewer';
    } catch (error) {
      return 'viewer';
    }
  };

  // Cache role to localStorage
  const setCachedRole = (uid, role) => {
    try {
      localStorage.setItem(`userRole_${uid}`, role);
    } catch (error) {
      console.error('Error caching role:', error);
    }
  };

  // Setup reCAPTCHA for phone authentication
  const setupRecaptcha = (phoneNumber) => {
    try {
      if (!window.recaptchaVerifier) {
        window.recaptchaVerifier = new RecaptchaVerifier(auth, 'recaptcha-container', {
          size: 'invisible',
          callback: (response) => {
            console.log('reCAPTCHA verified');
          },
          'expired-callback': () => {
            console.log('reCAPTCHA expired');
          }
        });
      }
      return window.recaptchaVerifier;
    } catch (error) {
      console.error('reCAPTCHA setup error:', error);
      toast.error('‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå Login ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ Email ‡∏´‡∏£‡∏∑‡∏≠ Google');
      throw error;
    }
  };  // Get user role from Firestore
  const getUserRole = async (uid) => {
    try {
      const userDoc = await getDoc(doc(db, 'users', uid));
      if (userDoc.exists()) {
        return userDoc.data().role || 'viewer';
      }
      return 'viewer';
    } catch (error) {
      console.error('Error getting user role:', error);
      return 'viewer';
    }
  };

  // Create or update user profile in Firestore
  const createUserProfile = async (user, additionalData = {}) => {
    try {
      const userRef = doc(db, 'users', user.uid);
      const userDoc = await getDoc(userRef);
      
      if (!userDoc.exists()) {
        // Create new user profile with default viewer role
        await setDoc(userRef, {
          uid: user.uid,
          email: user.email,
          displayName: user.displayName || additionalData.displayName || '',
          phoneNumber: user.phoneNumber || additionalData.phoneNumber || '',
          role: 'viewer', // Default role
          createdAt: new Date(),
          lastLoginAt: new Date(),
          isActive: true,
          ...additionalData
        });
        setCachedRole(user.uid, 'viewer'); // Cache new user role
        return 'viewer';
      } else {
        // Update last login time
        await updateDoc(userRef, {
          lastLoginAt: new Date()
        });
        const role = userDoc.data().role || 'viewer';
        setCachedRole(user.uid, role); // Cache existing user role
        return role;
      }
    } catch (error) {
      console.error('Error creating/updating user profile:', error);
      return 'viewer';
    }
  };

  // Email/Password Login
  const loginWithEmail = async (email, password) => {
    try {
      setLoading(true);
      const result = await signInWithEmailAndPassword(auth, email, password);
      const role = await createUserProfile(result.user);
      setUserRole(role);
      setCachedRole(result.user.uid, role); // Cache role after login
      toast.success('‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! üéâ');
      return { success: true, user: result.user, role };
    } catch (error) {
      console.error('Email login error:', error);
      let errorMessage = '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö';
      
      switch (error.code) {
        case 'auth/user-not-found':
          errorMessage = '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ô‡∏µ‡πâ';
          break;
        case 'auth/wrong-password':
          errorMessage = '‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á';
          break;
        case 'auth/invalid-email':
          errorMessage = '‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á';
          break;
        case 'auth/too-many-requests':
          errorMessage = '‡∏•‡∏≠‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà';
          break;
      }
      
      toast.error(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  };

  // Email/Password Registration
  const registerWithEmail = async (email, password, displayName) => {
    try {
      setLoading(true);
      const result = await createUserWithEmailAndPassword(auth, email, password);
      const role = await createUserProfile(result.user, { displayName });
      setUserRole(role);
      setCachedRole(result.user.uid, role); // Cache role after registration
      toast.success('‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! üéâ');
      return { success: true, user: result.user, role };
    } catch (error) {
      console.error('Email registration error:', error);
      let errorMessage = '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏±‡∏ç‡∏ä‡∏µ';
      
      switch (error.code) {
        case 'auth/email-already-in-use':
          errorMessage = '‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß';
          break;
        case 'auth/weak-password':
          errorMessage = '‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 6 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£';
          break;
        case 'auth/invalid-email':
          errorMessage = '‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á';
          break;
      }
      
      toast.error(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  };

  // Google Login
  const loginWithGoogle = async () => {
    try {
      setLoading(true);
      const provider = new GoogleAuthProvider();
      const result = await signInWithPopup(auth, provider);
      const role = await createUserProfile(result.user);
      setUserRole(role);
      setCachedRole(result.user.uid, role); // Cache role after Google login
      toast.success('‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡πâ‡∏ß‡∏¢ Google ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! üéâ');
      return { success: true, user: result.user, role };
    } catch (error) {
      console.error('Google login error:', error);
      let errorMessage = '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡πâ‡∏ß‡∏¢ Google';
      
      switch (error.code) {
        case 'auth/popup-closed-by-user':
          errorMessage = '‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å';
          break;
        case 'auth/operation-not-allowed':
          errorMessage = 'Google Login ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô Firebase Console ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô Authentication > Sign-in method';
          break;
        case 'auth/popup-blocked':
          errorMessage = 'Popup ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Ñ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï popup ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ß‡πá‡∏ö‡πÑ‡∏ã‡∏ï‡πå‡∏ô‡∏µ‡πâ';
          break;
        case 'auth/cancelled-popup-request':
          errorMessage = '‡∏°‡∏µ popup ‡∏≠‡∏∑‡πà‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà';
          break;
      }
      
      toast.error(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  };

  // Phone Number Login
  const loginWithPhone = async (phoneNumber) => {
    try {
      setLoading(true);
      const appVerifier = setupRecaptcha();
      
      const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, appVerifier);
      
      toast.success('‡∏™‡πà‡∏á‡∏£‡∏´‡∏±‡∏™ OTP ‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°');
      return { 
        success: true, 
        confirmationResult,
        message: '‡∏™‡πà‡∏á‡∏£‡∏´‡∏±‡∏™ OTP ‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°' 
      };
    } catch (error) {
      console.error('Phone login error:', error);
      let errorMessage = '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏£‡∏´‡∏±‡∏™ OTP';
      
      switch (error.code) {
        case 'auth/invalid-phone-number':
          errorMessage = '‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á';
          break;
        case 'auth/too-many-requests':
          errorMessage = '‡∏™‡πà‡∏á‡∏£‡∏´‡∏±‡∏™‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà';
          break;
        case 'auth/configuration-not-found':
          errorMessage = 'Phone Authentication ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ Email ‡∏´‡∏£‡∏∑‡∏≠ Google Login';
          break;
        case 'auth/app-not-authorized':
          errorMessage = '‡πÅ‡∏≠‡∏õ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ Phone Authentication';
          break;
        case 'auth/billing-not-enabled':
          errorMessage = 'Phone Authentication ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ Firebase Blaze Plan ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ Email ‡∏´‡∏£‡∏∑‡∏≠ Google Login ‡πÅ‡∏ó‡∏ô';
          break;
        case 'auth/operation-not-allowed':
          errorMessage = 'Phone Authentication ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ Email ‡∏´‡∏£‡∏∑‡∏≠ Google Login';
          break;
      }
      
      toast.error(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  };

  // Verify OTP for phone login
  const verifyOTP = async (confirmationResult, otp) => {
    try {
      setLoading(true);
      const result = await confirmationResult.confirm(otp);
      const role = await createUserProfile(result.user);
      setUserRole(role);
      toast.success('‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! üéâ');
      return { success: true, user: result.user, role };
    } catch (error) {
      console.error('OTP verification error:', error);
      let errorMessage = '‡∏£‡∏´‡∏±‡∏™ OTP ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á';
      
      if (error.code === 'auth/invalid-verification-code') {
        errorMessage = '‡∏£‡∏´‡∏±‡∏™ OTP ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á';
      }
      
      toast.error(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  };

  // Legacy login method (for backward compatibility)
  const login = async (email, password) => {
    return await loginWithEmail(email, password);
  };

  // Logout
  const logout = useCallback(async () => {
    try {
      await signOut(auth);
      setUser(null);
      setUserRole('viewer'); // Reset to viewer role after logout
      setIsAuthenticated(false);
      toast.success('‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß');
      return { success: true };
    } catch (error) {
      console.error('Logout error:', error);
      toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö');
      return { success: false, error: error.message };
    }
  }, []);

  // Get user display name
  const getUserDisplayName = useCallback(() => {
    return user?.displayName || user?.email?.split('@')[0] || '‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ';
  }, [user]);

  // Update user role (Admin only)
  const updateUserRole = async (targetUserId, newRole) => {
    try {
      if (userRole !== 'admin') {
        toast.error('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ');
        return { success: false, error: 'Unauthorized' };
      }

      const userRef = doc(db, 'users', targetUserId);
      await updateDoc(userRef, {
        role: newRole,
        updatedAt: new Date()
      });

      toast.success(`‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô ${newRole === 'admin' ? '‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏∞‡∏ö‡∏ö' : '‡∏ú‡∏π‡πâ‡∏ä‡∏°'} ‡πÅ‡∏•‡πâ‡∏ß`);
      return { success: true };
    } catch (error) {
      console.error('Error updating user role:', error);
      toast.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ');
      return { success: false, error: error.message };
    }
  };

  // Get all users (Admin only)
  const getAllUsers = async () => {
    try {
      if (userRole !== 'admin') {
        return { success: false, error: 'Unauthorized' };
      }

      const usersQuery = query(collection(db, 'users'), orderBy('createdAt', 'desc'));
      const usersSnapshot = await getDocs(usersQuery);
      const users = usersSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));

      return { success: true, users };
    } catch (error) {
      console.error('Error getting users:', error);
      return { success: false, error: error.message };
    }
  };

  // Delete user (Admin only)
  const deleteUser = async (userId) => {
    if (userRole !== 'admin') {
      toast.error('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ');
      return { success: false };
    }

    if (userId === user?.uid) {
      toast.error('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡πÑ‡∏î‡πâ');
      return { success: false };
    }

    try {
      setLoading(true);
      // Delete user document from Firestore
      const userRef = doc(db, 'users', userId);
      await deleteDoc(userRef);

      toast.success('‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
      return { success: true };
    } catch (error) {
      console.error('Error deleting user:', error);
      toast.error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ');
      return { success: false, error: error.message };
    } finally {
      setLoading(false);
    }
  };

  // Check if user has specific permission
  const hasPermission = (requiredRole) => {
    if (requiredRole === 'viewer') {
      return true; // Everyone can view (including non-authenticated users)
    }
    if (requiredRole === 'admin') {
      return userRole === 'admin';
    }
    return false;
  };

  // Check if user is admin
  const isAdmin = () => {
    return userRole === 'admin';
  };

  // Check if user is viewer
  const isViewer = () => {
    return userRole === 'viewer';
  };

  // Auth state listener with caching
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      if (user) {
        setUser(user);
        setIsAuthenticated(true);
        
        // ‡πÉ‡∏ä‡πâ cached role ‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Firestore ‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á
        const cachedRole = getCachedRole(user.uid);
        setUserRole(cachedRole);
        
        // ‡πÇ‡∏´‡∏•‡∏î role ‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å Firestore ‡πÅ‡∏•‡πâ‡∏ß update cache
        if (!isInitialized) {
          try {
            const actualRole = await getUserRole(user.uid);
            if (actualRole !== cachedRole) {
              setUserRole(actualRole);
              setCachedRole(user.uid, actualRole);
            }
          } catch (error) {
            console.error('Error fetching user role:', error);
          }
        }
      } else {
        setUser(null);
        setIsAuthenticated(false);
        setUserRole('viewer');
        // Clear cached role on logout
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith('userRole_')) {
              localStorage.removeItem(key);
            }
          });
        } catch (error) {
          console.error('Error clearing cached roles:', error);
        }
      }
      setLoading(false);
      setIsInitialized(true);
    });

    return unsubscribe;
  }, [isInitialized]);

  const value = {
    // User state
    user,
    role: userRole,
    permissions: {
      canEdit: userRole === 'admin',
      canViewReports: true, // Everyone can view reports
      canManageUsers: userRole === 'admin'
    },
    userRole, // Keep for backward compatibility
    loading,
    isAuthenticated,
    
    // Authentication methods
    login, // Legacy method
    loginWithEmail,
    registerWithEmail,
    loginWithGoogle,
    loginWithPhone,
    verifyOTP,
    logout,
    
    // User management (Admin only)
    updateUserRole,
    getAllUsers,
    deleteUser,
    
    // Permission checking
    hasPermission,
    isAdmin,
    isViewer,
    
    // Utility
    createUserProfile,
    getUserDisplayName
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
      {/* reCAPTCHA container for phone auth */}
      <div id="recaptcha-container"></div>
    </AuthContext.Provider>
  );
};
